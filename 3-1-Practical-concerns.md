## 3-1. Computational thinking and practical concerns

1. Making a plan. (Test cases, pass)
2. Brute force algorithms.
3. Runtime and memory differences (for loops, comprehension, lists vs iterators)
4. Debug tools (printing, assert)
5. Python 2 vs Python 3, continued.

**Project**: Project Euler Problems 81, 82, 83 (part 1)

## 1. Making a plan. (Test cases, pass)

When solving a problem, it can be helpful to use simplified data or cases when checking that the code works as intended. 

## 2. Brute force algorithms.

A **brute force** algorithm is one that runs through all possible cases, without using any observations to help speed up the runtime. These can be helpful when working with small cases, but should be avoided for larger data. Use modules and packages when possible instead of rewriting code; it's likely that their code is more efficient.

```python
# Brute Force CRT

# 
```

## 3. Runtime and memory differences (for loops, comprehension, lists vs iterators)

## 4. Debug tools (printing, assert)

## 5. Python 2 vs Python 3, continued.

## Project 1. Project Euler Problem 34

Solve [Project Euler Problem 34](https://projecteuler.net/problem=34) which has do with factorials. First make a plan, and make some simplifying mathematical assumptions.

## Project 2. 81, 82, 83 (part 1)

These problems all build on each other and involve finding the shortest path through a grid. Make a plan for finding the answer.

1. Understand the math involved.
2. How do you measure what you're looking for? Must you use brute force, or is there another option?
3. How does this problem work in the 2x3 case, or the 3x3 case?
4. What will your code loop over, and in what order?
5. What will your code do at each stage? Will that operation require a "helper function"?
